package blobstore

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"testing"

	"github.com/numtide/go-nix/nixbase32"
	"github.com/stretchr/testify/assert"
)

func TestCasyncStore(t *testing.T) {
	// populate castr dir
	castrDir, err := ioutil.TempDir("", "castr")
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		os.RemoveAll(castrDir)
	})

	// populate caidx dir
	caidxDir, err := ioutil.TempDir("", "caidx")
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		os.RemoveAll(caidxDir)
	})

	// init casync store
	caStore, err := NewCasyncStore(castrDir, caidxDir)
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		caStore.Close()
	})
	testBlobStore(t, caStore)
}

func TestMemoryStore(t *testing.T) {
	memoryStore := NewMemoryStore()
	t.Cleanup(func() {
		memoryStore.Close()
	})
	testBlobStore(t, memoryStore)
}

// testBlobStore runs all nar tests, with a Narstore generated by storeGenerator.
func testBlobStore(t *testing.T, blobStore BlobStore) {
	narhashStr := "0mw6qwsrz35cck0wnjgmfnjzwnjbspsyihnfkng38kxghdc9k9zd"
	narhash := nixbase32.MustDecodeString(narhashStr)
	testFilePath := "../../../test/compression_none/nar/" + narhashStr + ".nar"

	fileInfo, err := os.Stat(testFilePath)
	if err != nil {
		panic(err)
	}
	narSize := fileInfo.Size()

	t.Run("GetBlobNotFound", func(t *testing.T) {
		_, _, err := blobStore.GetBlob(context.Background(), narhash)
		if assert.Error(t, err) {
			assert.ErrorIsf(t, err, os.ErrNotExist, "on a non-existent blob, there should be a os.ErrNotExist in the error chain")
		}
	})

	t.Run("PutBlob", func(t *testing.T) {
		w, err := blobStore.PutBlob(context.Background())
		assert.NoError(t, err)
		defer w.Close()

		tdr := readTestData(testFilePath)
		defer tdr.Close()
		n, err := io.Copy(w, tdr)

		assert.NoError(t, err)
		assert.Equal(t, narSize, n)
		assert.NoError(t, w.Close())

		fmt.Printf("%v", w.Sha256Sum())

		assert.Equal(t, narhash, w.Sha256Sum(), "narhash should be correctly calculated")
	})

	t.Run("PutBlob again", func(t *testing.T) {
		w, err := blobStore.PutBlob(context.Background())
		assert.NoError(t, err)
		defer w.Close()

		tdr := readTestData(testFilePath)
		defer tdr.Close()
		n, err := io.Copy(w, tdr)
		assert.NoError(t, err)

		assert.Equal(t, narSize, n)
		assert.NoError(t, w.Close())

		fmt.Printf("%x\n", w.Sha256Sum())

		assert.Equal(t, narhash, w.Sha256Sum(), "narhash should still be correctly calculated")
	})

	t.Run("PutNar,then abort", func(t *testing.T) {
		w, err := blobStore.PutBlob(context.Background())
		assert.NoError(t, err)
		assert.NoError(t, w.Close())
	})

	t.Run("GetBlob", func(t *testing.T) {
		r, n, err := blobStore.GetBlob(context.Background(), narhash)

		assert.NoError(t, err)
		assert.Equal(t, narSize, n)

		actualContents, err := io.ReadAll(r)
		assert.NoError(t, err)

		tdr := readTestData(testFilePath)
		defer tdr.Close()

		expectedContents, err := ioutil.ReadAll(tdr)
		assert.NoError(t, err)
		assert.Equal(t, expectedContents, actualContents)
	})

	t.Run("GetNar,then abort", func(t *testing.T) {
		r, _, err := blobStore.GetBlob(context.Background(), narhash)

		assert.NoError(t, err)
		assert.NoError(t, r.Close())
	})
}

// readTestData reads a test file and returns a io.Reader to it
// if there's an error acessing the file, it panics
func readTestData(path string) io.ReadSeekCloser {
	f, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	return f
}
