package store

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"testing"

	"github.com/numtide/go-nix/nar/narinfo"
	"github.com/numtide/go-nix/nixbase32"
	"github.com/stretchr/testify/assert"
)

func TestCasyncStore(t *testing.T) {
	// populate castr dir
	castrDir, err := ioutil.TempDir("", "castr")
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		os.RemoveAll(castrDir)
	})

	// populate caidx dir
	caidxDir, err := ioutil.TempDir("", "caidx")
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		os.RemoveAll(caidxDir)
	})

	// init casync store
	caStore, err := NewCasyncStore(castrDir, caidxDir)
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		caStore.Close()
	})
	testNar(t, caStore)
	//testNarinfo(t, caStore)
}

func TestMemoryStore(t *testing.T) {
	memoryStore := NewMemoryStore()
	t.Cleanup(func() {
		memoryStore.Close()
	})
	testNar(t, memoryStore)
	testNarinfo(t, memoryStore)
}

func TestFileStore(t *testing.T) {
	tmpDir, err := ioutil.TempDir("", "narinfo")
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		os.RemoveAll(tmpDir)
	})
	fileStore, err := NewFileStore(tmpDir)
	if err != nil {
		panic(err)
	}
	t.Cleanup(func() {
		fileStore.Close()
	})
	testNarinfo(t, fileStore)
}

// readTestData reads a test file and returns a io.Reader to it
// if there's an error acessing the file, it panics
func readTestData(path string) io.ReadSeekCloser {
	f, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	return f
}

// testNar runs all nar tests, with a Narstore generated by storeGenerator.
func testNar(t *testing.T, store NarStore) {
	narhashStr := "0mw6qwsrz35cck0wnjgmfnjzwnjbspsyihnfkng38kxghdc9k9zd"
	narhash := nixbase32.MustDecodeString(narhashStr)
	testFilePath := "../../test/compression_none/nar/" + narhashStr + ".nar"

	fileInfo, err := os.Stat(testFilePath)
	if err != nil {
		panic(err)
	}
	narSize := fileInfo.Size()

	t.Run("GetNarNotFound", func(t *testing.T) {
		_, _, err := store.GetNar(context.Background(), narhash)
		if assert.Error(t, err) {
			assert.Equal(t, ErrNotFound, err)
		}
	})

	t.Run("PutNar", func(t *testing.T) {
		w, err := store.PutNar(context.Background())
		assert.NoError(t, err)
		defer w.Close()

		tdr := readTestData(testFilePath)
		defer tdr.Close()
		n, err := io.Copy(w, tdr)

		assert.NoError(t, err)
		assert.Equal(t, narSize, n)
		assert.NoError(t, w.Close())

		fmt.Printf("%v", w.Sha256Sum())

		assert.Equal(t, narhash, w.Sha256Sum(), "narhash should be correctly calculated")
	})

	t.Run("PutNar again", func(t *testing.T) {
		w, err := store.PutNar(context.Background())
		assert.NoError(t, err)
		defer w.Close()

		tdr := readTestData(testFilePath)
		defer tdr.Close()
		n, err := io.Copy(w, tdr)
		assert.NoError(t, err)

		assert.Equal(t, narSize, n)
		assert.NoError(t, w.Close())

		fmt.Printf("%x\n", w.Sha256Sum())

		assert.Equal(t, narhash, w.Sha256Sum(), "narhash should still be correctly calculated")
	})

	t.Run("PutNar,then abort", func(t *testing.T) {
		w, err := store.PutNar(context.Background())
		assert.NoError(t, err)
		assert.NoError(t, w.Close())
	})

	t.Run("GetNar", func(t *testing.T) {
		r, n, err := store.GetNar(context.Background(), narhash)

		assert.NoError(t, err)
		assert.Equal(t, narSize, n)

		actualContents, err := io.ReadAll(r)
		assert.NoError(t, err)

		tdr := readTestData(testFilePath)
		defer tdr.Close()

		expectedContents, err := ioutil.ReadAll(tdr)
		assert.NoError(t, err)
		assert.Equal(t, expectedContents, actualContents)
	})

	t.Run("GetNar,then abort", func(t *testing.T) {
		r, _, err := store.GetNar(context.Background(), narhash)

		assert.NoError(t, err)
		assert.NoError(t, r.Close())
	})
}

// testNarinfo runs all nar tests, with a NarinfoStore generated by storeGenerator.
func testNarinfo(t *testing.T, store NarinfoStore) {
	outputhashStr := "dr76fsw7d6ws3pymafx0w0sn4rzbw7c9"
	outputhash := nixbase32.MustDecodeString(outputhashStr)
	testFilePath := "../../test/compression_none/" + outputhashStr + ".narinfo"

	t.Run("GetNarinfoNotFound", func(t *testing.T) {
		_, err := store.GetNarInfo(context.Background(), outputhash)
		if assert.Error(t, err) {
			assert.Equal(t, ErrNotFound, err)
		}
	})

	t.Run("PutNar", func(t *testing.T) {
		tdr := readTestData(testFilePath)
		defer tdr.Close()

		ni, err := narinfo.Parse(tdr)
		assert.NoError(t, err)
		err = store.PutNarInfo(context.Background(), outputhash, ni)
		assert.NoError(t, err)
	})

	t.Run("PutNar again", func(t *testing.T) {
		tdr := readTestData(testFilePath)
		defer tdr.Close()

		ni, err := narinfo.Parse(tdr)
		assert.NoError(t, err)
		err = store.PutNarInfo(context.Background(), outputhash, ni)
		assert.NoError(t, err)
	})

	t.Run("GetNar", func(t *testing.T) {
		tdr := readTestData(testFilePath)
		defer tdr.Close()
		expectedContents, err := io.ReadAll(tdr)
		if err != nil {
			t.Fatal(err)
		}

		ni, err := store.GetNarInfo(context.Background(), outputhash)
		assert.NoError(t, err)
		assert.Equal(t, string(expectedContents), ni.String())
	})
}
